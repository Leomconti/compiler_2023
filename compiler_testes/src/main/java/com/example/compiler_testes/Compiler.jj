options {
    STATIC = false;

}

PARSER_BEGIN(Compiler)
package com.example.compiler_testes;


public class Compiler {
    public static void main(String[] args) {
        // Test the lexer here

    }
}

PARSER_END(Compiler)

TOKEN_MGR_DECLS :
{
    String mensagem = "";
    int countLexErrors = 0;


    public String getMensagens() {
        return mensagem;
    }

    public int foundLexErrors() {
        return countLexErrors;
    }

    void CommentError()
        {
            System.err.println("Error: Multiline comment not closed.");
        }
}

SKIP :
{
    " " | "\t" | "\n" | "\r"
    | "/*" : multilinecomment
    | "//" : singlelinecomment
}

<singlelinecomment> SKIP :
{
    <["\n", "\r"]>: DEFAULT
|    < ~[] >
}

<multilinecomment> SKIP :
{
    "*/": DEFAULT
|   < ~[] >
}

// Palavras reservadas
TOKEN :

{
    < IDENTIFICADOR: <MAIUSCULA> ((<DIGITO> | (<DIGITO> <DIGITO>))? (("_") | (<LETRA>)+("_")?)+)* >
|   < RESULT: "result" >
|   < AVALIATE: "avaliate" >
|   < DO: "do" >
|   < THIS: "this" >
|   < BODY: "body" >
|   < DESCRIPTION: "description" >
|   < DECLARATION: "declaration" >
|   < TYPE: "type" >
|   < IS: "is" >
|   < CONSTANT: "constant" >
|   < AND: "and" >
|   < VARIABLE: "variable" >
|   < DESIGNATE: "designate" >
|   < AS: "as" >
|   < READ: "read" >
|   < WRITE: "write" >
|   < ALL: "all" >
|   < REPEAT: "repeat" >
|   < INTEGER_DEF: "integer" >
|   < REAL_DEF: "real" >
|   < LITERAL_DEF: "literal" >
|   < LOGIC_DEF: "logic" >
}

// Valores
TOKEN :
{
    < INTEGER: <DIGITO> | <DIGITO> <DIGITO> | <DIGITO> <DIGITO> <DIGITO> >
|   < REAL:  (<INTEGER> | <DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> | <DIGITO> <DIGITO> <DIGITO> <DIGITO>) "." <INTEGER> >
|   < TRUE: "true">
|   < UNTRUE: "untrue">
|   < LITERAL: ("\"" ( <ASCII_ASPAS> )* "\"") | "\'" ( <ASCII_APOSTROFO> )* "\'" >
}

// Operadores aritmeticos
TOKEN :
{
    < PLUS: "+" >
|   < MINUS: "-" >
|   < MULTIPLY: "*" >
|   < DIVIDE: "/" >
|   < POWER: "**" >
|   < MODULO: "%" >
|   < DOUBLE_MODULO: "%%" >
}

// Relational Operators
TOKEN :
{
    < LESS_THAN: "<<" >
|   < LESS_THAN_EQUAL: "<<=" >
|   < GREATER_THAN_EQUAL: ">>=" >
|   < GREATER_THAN: ">>" >
|   < EQUAL: "==" >
|   < NOT_EQUAL: "!=" >
}

// Operadores logicos
TOKEN :
{
    < AND_LOGIC: "&" >
|   < OR_LOGIC: "|" >
|   < NOT_LOGIC: "!" >
}

// Caracteres Especiais
TOKEN :
{
    < HASH: "#" >
|   < DOLLAR: "$" >
|   < OPEN_PAREN: "(" >
|   < CLOSE_PAREN: ")" >
|   < COMMA: "," >
|   < DOT: "." >
|   < COLON: ":" >
|   < SEMICOLON: ";" >
|   < S_LESS_THAN: "<" >
|   < S_GREATER_THAN: ">" >
|   < QUESTION_MARK: "?" >
|   < AT_SIGN: "@" >
|   < OPEN_BRACKET: "[" >
|   < CLOSE_BRACKET: "]" >
|   < BACKTICK: "`" >
|   < OPEN_BRACE: "{" >
|   < CLOSE_BRACE: "}" >
|   < TILDE: "~" >
|   < EQUALS: "=" >
}

// Comentarios
//TOKEN :
//{
////    < COMENTARIOLINHA: "//" ( <DENTROSEMLINHA> )* ("\n")? >
////|   < COMENTARIOBLOCO: "/*" (( <SEM_ESTRELA> | (("*")+ <SEM_BARRA>) )*) "*/" >
//}

// Auxiliares
TOKEN :
{
    < #MAIUSCULA: ["A"-"Z"] >
|   < #MINUSCULA: ["a"-"z"] >
|   < #DIGITO: ["0"-"9"] >
|   < #LETRA: <MAIUSCULA> | <MINUSCULA> >
|   < #ASCII: ["\u0000" - "\u007F"] >
|   < #ASCII_ASPAS: ["\u0000" - "\u0021"] | ["\u0023" - "\u007F"] >
|   < #ASCII_APOSTROFO: ["\u0000" - "\u0026"] | ["\u0028" - "\u007F"] >
|   < #DENTROSEMLINHA: ["\u0000" - "\u0009", "\u000B" - "\u007F"] >  // tabela ascii sem o \n (quebra de linha, vulgo final)
|   < #SEM_ESTRELA: ["\u0000"-"\u0029"] | ["\u002B"-"\uFFFF"] >  // ascii sem estrela
|   < #SEM_BARRA: ["\u0000"-"\u002E"] | ["\u0030"-"\uFFFF"] >  // ascci sem a barra (para nao poder colocar estrela e barra e contar como inside do texto ali )
}

// Erros
SPECIAL_TOKEN :
{
    < INVALID_LEXICAL : (~ ["a"-"z", "A"-"Z", "0"-"9"," ","\t","\n","\r","\f","\'", "\"","+", "-", "*", "/", "%","<", ">", "=", ".", ",", ";", "(", ")", "[", "]", "{", "}"])+>
   {System.err.println("Line: " + input_stream.getEndLine() + " Column: " + input_stream.getEndColumn() + " Invalid string found: " + image);
    countLexErrors++;
    }
|  <INVALID_CONST: "\"" (~ ["\n", "\r", "\""])* ["\n", "\r"]>
    {System.err.println("Line: " + input_stream.getEndLine() + " Column: " + input_stream.getEndColumn() + " String constatnt has a \\n: " + image);
     countLexErrors++;
     }
}
    //{mensagem += "Erro! Caractere inválido. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
// Palavras reservadas

// Valores
SPECIAL_TOKEN :
{
    < ERROR_INTEGER: <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ >
    {mensagem += "\nErro! Limite de dígitos para uma constante inteira = 3. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_REAL:  <DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ "." <INTEGER> >
    {mensagem += "\nErro! Mais de 5 dígitos antes do ponto. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_LITERAL_START: (( <ASCII_ASPAS> )* "\"" | ( <ASCII_APOSTROFO> )* "\'") >
    {mensagem += "\nErro! Literal sem aspas no início. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_LITERAL_END: (( <ASCII_ASPAS> )* "\"" | ( <ASCII_APOSTROFO> )* "\'") >
    {mensagem += "\nErro! Literal sem aspas de fechamento. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
}

SPECIAL_TOKEN :
{
    < ERROR_IDENTIFICADOR: <MAIUSCULA> ((<DIGITO>)+ (("_") | (<LETRA>)+("_")?)+)* >
    {mensagem += "\nErro! Identificador com muitos dígitos. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_START_DIGIT: <DIGITO> (<LETRA> | <DIGITO> | "_")+ >
    {mensagem += "\nErro! Identificador começando com dígito. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_MULTIPLE_UNDERSCORES: <MAIUSCULA> ((<LETRA> | <DIGITO>)* "__" (<LETRA> | <DIGITO> | "_")*)+ >
    {mensagem += "\nErro! Identificador com múltiplos underscores consecutivos. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_END_UNDERSCORE: <MAIUSCULA> ((<LETRA> | <DIGITO>)+ "_")+ >
    {mensagem += "\nErro! Identificador terminando com underscore. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_START_LOWERCASE: <MINUSCULA> ((<LETRA> | <DIGITO> | "_")+)* >
    {mensagem += "\nErro! Identificador começando com letra minúscula. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
}

double programa():{}
{
    <DO> <THIS> <IDENTIFICADOR> <OPEN_BRACKET><CLOSE_BRACKET> enumerado() constAndVars() <BODY> [listaComandos()] finalPrograma()
}

double finalPrograma():{}
{
    (<DESCRIPTION> <COMENTARIO>)?
}

double enumerado():{}
{
    (<DECLARATION> <TYPE> <OPEN_BRACKET> listaIs() <CLOSE_BRACKET> <DOT>)?
}

double atribuicao():{}
{
    <DESIGNATE> <THIS> listaIdent() <AS> expressao()
}

double saida():{}
{
    <WRITE>  <OPEN_BRACKET> listaIdentConst() <CLOSE_BRACKET> <DOT>
}

double write():{}
{
    <WRITE> <ALL> <THIS> | <WRITE> <THIS>
}

double entrada():{}
{
    <READ> <THIS> <OPEN_BRACKET> listaIdent() <CLOSE_BRACKET> <DOT>
}

double selecao():{}
{
    <AVALIATE> <THIS> expressao() <TRUE> <RESULT> <OPEN_BRACKET> listaComandos() <CLOSE_BRACKET> <UNTRUE> <RESULT> <OPEN_BRACKET> listaComandos() <CLOSE_BRACKET>
}

double comandos():{}
{
    atribuicao() | entrada() | saida() |selecao() | repeticao()
}

double listaComandos():{}
{
    comandos() comCont()
}

double comCont():{}
{
    (listaComandos())?
}

double constAndVars():{}
{
    (<DECLARATION> <CONSTANT> <AND> <VARIABLE> <OPEN_BRACKET> cV() <CLOSE_BRACKET> <DOT>)?
}

double asC():{}
{
    listaIdent() <IS> tipoC() <EQUALS> valor()
}

double asV():{}
{
    listaIdent() <IS> tipoV()
}

double tipoC():{}
{
    <INTEGER_DEF> | <REAL_DEF> | <LITERAL_DEF> | <LOGIC_DEF>
}

double tipoV():{}
{
    <INTEGER_DEF> | <REAL_DEF> | <LITERAL_DEF> | <LOGIC_DEF>
}

double valor():{}
{
    <CONSTANT> <INTEGER_DEF> | <CONSTANT> <REAL_DEF> | <CONSTANT> <LITERAL_DEF>
}

double listaIdentsC():{}
{
    <IDENTIFICADOR> identCont()
}

double identCont():{}
{
    (","listaIdentsC())?
}

double listaIdent():{}
{
    <IDENTIFICADOR> tId() contId()
}

double tId():{}
{
    (<OPEN_BRACE> <CONSTANT> <INTEGER_DEF> <CLOSE_BRACE>)?
}

double contId():{}
{
    (listaIdent())?
}

double listaIdentConst():{}
{
    listaIdentConstI() <DOT> iCCont()
}

double listaIdentConstI():{}
{
    listaIdent() | <CONSTANT>
}

double iCCont():{}
{
    (listaIdentConst())?
}

double listaIs():{}
{
    <IDENTIFICADOR> <IS>  <OPEN_BRACE> listaIdent() <CLOSE_BRACE> isCont()
}

double isCont():{}
{
    (listaIs())?
}

double repeticao():{}
{
    <REPEAT> <THIS> expressao() <OPEN_BRACKET> listaComandos() <CLOSE_BRACKET>
}

double cV():{}
{
    <AS> <CONSTANT> asC() contCV() | <AS> <VARIABLE> asV()
}

double contCV():{}
{
    (<AS> <VARIABLE> asV())?
}

void expressao():
{}
{
    expressaoAritOuLogica() expressao_()
}

// the [] means that the token is optional, sooo, it's basically the OR Episolon
void expressao_():{}
{
    [
      <EQUAL> expressaoAritOuLogica()
    | <NOT_EQUAL> expressaoAritOuLogica()
    | <LESS_THAN> expressaoAritOuLogica()
    | <GREATER_THAN>  expressaoAritOuLogica()
    | <LESS_THAN_EQUAL> expressaoAritOuLogica()
    | <GREATER_THAN_EQUAL> expressaoAritOuLogica()
    ]
}

void expressaoAritOuLogica():{}
{
    termo2() menorPrioridade()
}

void menorPrioridade():{}
{
    [
      <PLUS> termo2() menorPrioridade()
    | <MINUS> termo2() menorPrioridade()
    | <OR_LOGIC> termo2() menorPrioridade()
    ]
}


void termo2():{}
{
    termo1() mediaPrioridade()
}

void mediaPrioridade():{}
{
      < MULTIPLY> termo1() mediaPrioridade()
    | < DIVIDE> termo1() mediaPrioridade()
    | < MODULO> termo1() mediaPrioridade()
    | < AND > termo1() mediaPrioridade()
    | < OR_LOGIC> termo1() mediaPrioridade()
}

void termo1():{}
{
    elemento() maiorPrioridade()
}

void maiorPrioridade(): {}
{
[
    < POWER > elemento() maiorPrioridade()
]
}

void elemento():{}
{
      < IDENTIFICADOR> indice()
    | < INTEGER>
    | < REAL >
    | < LITERAL >
    | < TRUE >
    | < UNTRUE>
    | <OPEN_PAREN> expressao() <CLOSE_PAREN>
    | <NOT_LOGIC> <OPEN_PAREN> expressao() <CLOSE_PAREN>
}

void indice(): {}
{
    [ <OPEN_BRACE> expressao() <CLOSE_BRACE> ]
}
