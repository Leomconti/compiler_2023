options {
    STATIC = false;

}

PARSER_BEGIN(Compiler)
package com.example.compiler_testes;


public class Compiler {
    public static void main(String[] args) {
    }

    public void handleError(ParseException e, String rule) {
            System.err.println("Rule: " + rule);
            System.err.println("Syntax Error: Line " + e.currentToken.next.beginLine + ", Column " + e.currentToken.next.beginColumn);
            System.err.println("Encountered: " + e.currentToken.next.image);

            if (e.expectedTokenSequences != null) {
                System.err.println("Expected: ");
                for (int[] expectedTokenSequence : e.expectedTokenSequences) {
                    for (int i = 0; i < expectedTokenSequence.length; i++) {
                        System.err.print(tokenImage[expectedTokenSequence[i]] + " ");
                    }
                    System.err.println("\n");
                }
            }
        }
}

PARSER_END(Compiler)

TOKEN_MGR_DECLS :
{
    String erroLexico = "";
    int countLexErrors = 0;
    String errorSintatico = "";
    public String getErroLexico() {
        return erroLexico;
    }

    public int foundLexErrors() {
        return countLexErrors;
    }

    void CommentError()
        {
            System.err.println("Error: Multiline comment not closed.");
        }
}

SKIP :
{
    " " | "\t" | "\n" | "\r"
    | "/*" : multilinecomment
    | "//" : singlelinecomment
}

<singlelinecomment> SKIP :
{
    <["\n", "\r"]>: DEFAULT
|    < ~[] >
}

<multilinecomment> SKIP :
{
    "*/": DEFAULT
|   < ~[] >
}

// Palavras reservadas
TOKEN :

{
    < IDENTIFICADOR: <MAIUSCULA> (<DIGITOS> <FIM>)? ((<_DIGITO> | <LETRA> (<DIGITOS>)? | <_LETRA> (<DIGITOS>)?)* <FIM>)? >
|   < RESULT: "result" >
|   < AVALIATE: "avaliate" >
|   < DO: "do" >
|   < THIS: "this" >
|   < BODY: "body" >
|   < DESCRIPTION: "description" >
|   < DECLARATION: "declaration" >
|   < TYPE: "type" >
|   < IS: "is" >
|   < CONSTANT: "constant" >
|   < AND: "and" >
|   < VARIABLE: "variable" >
|   < DESIGNATE: "designate" >
|   < AS: "as" >
|   < READ: "read" >
|   < WRITE: "write" >
|   < ALL: "all" >
|   < REPEAT: "repeat" >
|   < INTEGER_DEF: "integer" >
|   < REAL_DEF: "real" >
|   < LITERAL_DEF: "literal" >
|   < LOGIC_DEF: "logic" >
}

// indentificador valores
TOKEN :
{
    < #DIGITOS: <DIGITO> (<DIGITO>)? >
|   < #FIM: <_LETRA> | <LETRA> | "_" >
|   < #_DIGITO: "_" <DIGITOS> >
|   < #_LETRA: "_" (<LETRA>)+  >
}


// Valores
TOKEN :
{
    < INTEGER: <DIGITO> | <DIGITO> <DIGITO> | <DIGITO> <DIGITO> <DIGITO> >
|   < REAL:  (<INTEGER> | <DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> | <DIGITO> <DIGITO> <DIGITO> <DIGITO>) "." <INTEGER> >
|   < TRUE: "true">
|   < UNTRUE: "untrue">
|   < LITERAL: ("\"" ( <ASCII_ASPAS> )* "\"") | "\'" ( <ASCII_APOSTROFO> )* "\'" >
}

// Operadores aritmeticos
TOKEN :
{
    < PLUS: "+" >
|   < MINUS: "-" >
|   < MULTIPLY: "*" >
|   < DIVIDE: "/" >
|   < POWER: "**" >
|   < MODULO: "%" >
|   < DOUBLE_MODULO: "%%" >
}

// Relational Operators
TOKEN :
{
    < LESS_THAN: "<<" >
|   < LESS_THAN_EQUAL: "<<=" >
|   < GREATER_THAN_EQUAL: ">>=" >
|   < GREATER_THAN: ">>" >
|   < EQUAL: "==" >
|   < NOT_EQUAL: "!=" >
}

// Operadores logicos
TOKEN :
{
    < AND_LOGIC: "&" >
|   < OR_LOGIC: "|" >
|   < NOT_LOGIC: "!" >
}

// Caracteres Especiais
TOKEN :
{
    < HASH: "#" >
|   < DOLLAR: "$" >
|   < OPEN_PAREN: "(" >
|   < CLOSE_PAREN: ")" >
|   < COMMA: "," >
|   < DOT: "." >
|   < COLON: ":" >
|   < SEMICOLON: ";" >
|   < S_LESS_THAN: "<" >
|   < S_GREATER_THAN: ">" >
|   < QUESTION_MARK: "?" >
|   < AT_SIGN: "@" >
|   < OPEN_BRACKET: "[" >
|   < CLOSE_BRACKET: "]" >
|   < BACKTICK: "`" >
|   < OPEN_BRACE: "{" >
|   < CLOSE_BRACE: "}" >
|   < TILDE: "~" >
|   < EQUALS: "=" >
}

// Auxiliares
TOKEN :
{
    < #MAIUSCULA: ["A"-"Z"] >
|   < #MINUSCULA: ["a"-"z"] >
|   < #DIGITO: ["0"-"9"] >
|   < #LETRA: <MAIUSCULA> | <MINUSCULA> >
|   < #ASCII: ["\u0000" - "\u007F"] >
|   < #ASCII_ASPAS: ["\u0000" - "\u0021"] | ["\u0023" - "\u007F"] >
|   < #ASCII_APOSTROFO: ["\u0000" - "\u0026"] | ["\u0028" - "\u007F"] >
|   < #DENTROSEMLINHA: ["\u0000" - "\u0009", "\u000B" - "\u007F"] >  // tabela ascii sem o \n (quebra de linha, vulgo final)
|   < #SEM_ESTRELA: ["\u0000"-"\u0029"] | ["\u002B"-"\uFFFF"] >  // ascii sem estrela
|   < #SEM_BARRA: ["\u0000"-"\u002E"] | ["\u0030"-"\uFFFF"] >  // ascci sem a barra (para nao poder colocar estrela e barra e contar como inside do texto ali )
}

// Erros
SPECIAL_TOKEN :
{
    < INVALID_LEXICAL : (~ ["a"-"z", "A"-"Z", "0"-"9"," ","\t","\n","\r","\f","\'", "\"","+", "-", "*", "/", "%","<", ">", "=", ".", ",", ";", "(", ")", "[", "]", "{", "}"])+>
   {System.err.println("Line: " + input_stream.getEndLine() + " Column: " + input_stream.getEndColumn() + " Invalid string found: " + image);
    countLexErrors++;
    }
|  <INVALID_CONST: "\"" (~ ["\n", "\r", "\""])* ["\n", "\r"]>
    {System.err.println("Line: " + input_stream.getEndLine() + " Column: " + input_stream.getEndColumn() + " String constatnt has a \\n: " + image);
     countLexErrors++;
     }
}
    //{erroLexico += "Erro! Caractere inválido. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
// Palavras reservadas

// Valores
SPECIAL_TOKEN :
{
    < ERROR_INTEGER: <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ >
    {erroLexico += "\nErro! Limite de dígitos para uma constante inteira = 3. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_REAL:  <DIGITO> <DIGITO> <DIGITO> <DIGITO> <DIGITO> (<DIGITO>)+ "." <INTEGER> >
    {erroLexico += "\nErro! Mais de 5 dígitos antes do ponto. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_LITERAL_END: "\"" ( <ASCII_ASPAS> )* | "\'" (<ASCII_APOSTROFO>)* >
    {erroLexico += "\nErro! Literal sem aspas de fechamento. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
}

SPECIAL_TOKEN :
{
    < ERROR_IDENTIFICADOR: <MAIUSCULA> ((<DIGITO>)+ (("_") | (<LETRA>)+("_")?)+)* >
    {erroLexico += "\nErro! Identificador com muitos dígitos. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_START_DIGIT: <DIGITO> (<LETRA> | <DIGITO> | "_")+ >
    {erroLexico += "\nErro! Identificador começando com dígito. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_MULTIPLE_UNDERSCORES: <MAIUSCULA> ((<LETRA> | <DIGITO>)* "__" (<LETRA> | <DIGITO> | "_")*)+ >
    {erroLexico += "\nErro! Identificador com múltiplos underscores consecutivos. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_END_UNDERSCORE: <MAIUSCULA> ((<LETRA> | <DIGITO>)+ "_")+ >
    {erroLexico += "\nErro! Identificador terminando com underscore. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}

|   < ERROR_IDENTIFICADOR_START_LOWERCASE: <MINUSCULA> ((<LETRA> | <DIGITO> | "_")+)* >
    {erroLexico += "\nErro! Identificador começando com letra minúscula. Lexema: " + matchedToken.image + ", linha " + matchedToken.beginLine + ", coluna " + matchedToken.beginColumn;}
}

void programa(): {} {
    try {
        <DO> < THIS > < IDENTIFICADOR > < OPEN_BRACKET > < CLOSE_BRACKET > Declaration_Enumerado_E_ConstAndVars() < BODY > < OPEN_BRACKET > listaComandos() < CLOSE_BRACKET > finalPrograma()
    } catch (ParseException e) {
        handleError(e, "programa");
    }

}

void finalPrograma(): {} {
    try {
        ( < DESCRIPTION > < LITERAL > ) ?
    } catch (ParseException e) {
        handleError(e, "finalPrograma");
    }
}

void declaration_or_nothin():{}{
    try{
       [ <DECLARATION> combinedEnumAndConst()]
    }catch (ParseException e){
        handleError(e, "declaration_or_nothin");
    }
}

void combinedEnumAndConst(): {} {
    try {
        (enumeradoeouVars() | constAndVarsOnly())?
    } catch (ParseException e) {
        handleError(e, "combinedEnumAndConst");
    }
}

void enumeradoeouVars(): {} {
    try {
        <TYPE > < OPEN_BRACKET > lista_de_identificadores() < CLOSE_BRACKET > < DOT > ( < DECLARATION > constAndVarsOnly()) ?
    } catch (ParseException e) {
        handleError(e, "enumeradoeouVars");
    }
}

void constAndVarsOnly(): {} {
    try {
        <CONSTANT > < AND > < VARIABLE > < OPEN_BRACKET > cV() < CLOSE_BRACKET > < DOT >
    } catch (ParseException e) {
        handleError(e, "constAndVarsOnly");
    }
}

void atribuicao(): {} {
    try {
        <DESIGNATE > < THIS > listaIdent() < AS > expressao()
    } catch (ParseException e) {
        handleError(e, "atribuicao");
    }
}

void saida(): {} {
    try {
        <WRITE > < OPEN_BRACKET > listaIdentConst() < CLOSE_BRACKET > < DOT >
    } catch (ParseException e) {
        handleError(e, "saida");
    }
}

void write(): {} {
    try {
        <WRITE > write_()
    } catch (ParseException e) {
        handleError(e, "write");
    }
}

void write_(): {} {
    try {
        <ALL > < THIS > | < THIS >
    } catch (ParseException e) {
        handleError(e, "write_");
    }
}

void entrada(): {} {
    try {
        <READ > < THIS > < OPEN_BRACKET > listaIdent() < CLOSE_BRACKET > < DOT >
    } catch (ParseException e) {
        handleError(e, "entrada");
    }
}

void selecao(): {} {
    try {
        <AVALIATE > < THIS > expressao() < TRUE > < RESULT > < OPEN_BRACKET > listaComandos() < CLOSE_BRACKET > < UNTRUE > < RESULT > < OPEN_BRACKET > listaComandos() < CLOSE_BRACKET >
    } catch (ParseException e) {
        handleError(e, "selecao");
    }
}

void comando(): {} {
    try {
        atribuicao() | entrada() | saida() | selecao() | repeticao()
    } catch (ParseException e) {
        handleError(e, "comando");
    }
}

void listaComandos(): {} {
    try {
        comando() comando_adicional()
    } catch (ParseException e) {
        handleError(e, "listaComandos");
    }
}

void comando_adicional(): {} {
    try {
        (listaComandos()) ?
    } catch (ParseException e) {
        handleError(e, "comando_adicional");
    }
}

void as_contant(): {} {
    try {
        listaIdent() < IS > tipo_constante() < EQUALS > valor()
    } catch (ParseException e) {
        handleError(e, "as_contant");
    }
}

void as_variavel(): {} {
    try {
        listaIdent() < IS > tipo_variavel()
    } catch (ParseException e) {
        handleError(e, "as_variavel");
    }
}

void tipo_constante(): {} {
    try {
        <INTEGER_DEF > | < REAL_DEF > | < LITERAL_DEF > | < LOGIC_DEF >
    } catch (ParseException e) {
        handleError(e, "tipo_constante");
    }
}

void tipo_variavel(): {} {
    try {
        <INTEGER_DEF > | < REAL_DEF > | < LITERAL_DEF > | < LOGIC_DEF >
    } catch (ParseException e) {
        handleError(e, "tipo_variavel");
    }
}

void valor(): {} {
    try {
        <CONSTANT > valor_()
    } catch (ParseException e) {
        handleError(e, "valor");
    }
}

void valor_(): {} {
    <INTEGER_DEF > | < REAL_DEF > | < LITERAL_DEF >
}

void listaIdentsC(): {} {
    try {
        <IDENTIFICADOR > identCont()
    } catch (ParseException e) {
        handleError(e, "listaIdentsC");
    }
}

void identCont(): {} {
    try {
        ( < COMMA > listaIdentsC()) ?
    } catch (ParseException e) {
        handleError(e, "identCont");
    }
}

void listaIdent(): {} {
    try {
        <IDENTIFICADOR > tId() identificador_adicional()
    } catch (ParseException e) {
        handleError(e, "listaIdent");
    }
}

void tId(): {} {
    try {
        ( < OPEN_BRACE > < CONSTANT > < INTEGER_DEF > < CLOSE_BRACE > ) ?
    } catch (ParseException e) {
        handleError(e, "tId");
    }
}

void identificador_adicional(): {} {
    try {
        (listaIdent()) ?
    } catch (ParseException e) {
        handleError(e, "identificador_adicional");
    }
}

void listaIdentConst(): {} {
    try {
        listaIdentConstI() < DOT > Identificador_constante_adicional()
    } catch (ParseException e) {
        handleError(e, "listaIdentConst");
    }
}

void listaIdentConstI(): {} {
    try {
        listaIdent() | < CONSTANT >
    } catch (ParseException e) {
        handleError(e, "listaIdentConstI");
    }
}

void Identificador_constante_adicional(): {} {
    try {
        (listaIdentConst()) ?
    } catch (ParseException e) {
        handleError(e, "Identificador_constante_adicional");
    }
}

void lista_de_identificadores(): {} {
    try {
        <
        IDENTIFICADOR > < IS > < OPEN_BRACE > listaIdent() < CLOSE_BRACE > lista_de_Identificadores_adicional()
    } catch (ParseException e) {
        handleError(e, "lista_de_identificadores");
    }
}

void lista_de_Identificadores_adicional(): {} {
    try {
        (lista_de_identificadores()) ?
    } catch (ParseException e) {
        handleError(e, "lista_de_Identificadores_adicional");
    }
}

void repeticao(): {} {
    try {
        <
        REPEAT > < THIS > expressao() < OPEN_BRACKET > listaComandos() < CLOSE_BRACKET >
    } catch (ParseException e) {
        handleError(e, "repeticao");
    }
}

void cV(): {} {
    try {
        <
        AS > cV_()
    } catch (ParseException e) {
        handleError(e, "cV");
    }
}

void cV_(): {} {
    try {
        <CONSTANT > as_contant() contCV() | < VARIABLE > as_variavel()
    } catch (ParseException e) {
        handleError(e, "cV_");
    }
}

void contCV(): {} {
    try {
        ( < AS > < VARIABLE > as_variavel()) ?
    } catch (ParseException e) {
        handleError(e, "contCV");
    }
}

void expressao(): {} {
    try {
        expressaoAritOuLogica() expressao_()
    } catch (ParseException e) {
        handleError(e, "expressao");
    }
}

// the [] means that the token is optional, sooo, it's basically the OR Episolon
void expressao_(): {} {
    try {
        [ <
            EQUAL > expressaoAritOuLogica() |
            < NOT_EQUAL > expressaoAritOuLogica() |
            < LESS_THAN > expressaoAritOuLogica() |
            < GREATER_THAN > expressaoAritOuLogica() |
            < LESS_THAN_EQUAL > expressaoAritOuLogica() |
            < GREATER_THAN_EQUAL > expressaoAritOuLogica()
        ]
    } catch (ParseException e) {
        handleError(e, "expressao_");
    }

}

void expressaoAritOuLogica(): {} {
    try {
        termo2() menorPrioridade()
    } catch (ParseException e) {
        handleError(e, "expressaoAritOuLogica");
    }
}

void menorPrioridade(): {} {
        [ <
            PLUS > termo2() menorPrioridade() |
            < MINUS > termo2() menorPrioridade() |
            < OR_LOGIC > termo2() menorPrioridade()
        ]
}

void termo2(): {} {
        termo1() mediaPrioridade()
}

void mediaPrioridade(): {} {
             < MULTIPLY> termo1() mediaPrioridade()
           | < DIVIDE> termo1() mediaPrioridade()
           | < MODULO> termo1() mediaPrioridade()
           | < AND > termo1() mediaPrioridade()
           | < OR_LOGIC> termo1() mediaPrioridade()

}

void termo1(): {} {
        elemento() maiorPrioridade()
}

void maiorPrioridade(): {} {
        [ <POWER > elemento() maiorPrioridade() ]
}

void elemento(): {} {
    try {
          < IDENTIFICADOR> indice()
        | < INTEGER>
        | < REAL >
        | < LITERAL >
        | < TRUE >
        | < UNTRUE>
        | <OPEN_PAREN> expressao() <CLOSE_PAREN>
        | <NOT_LOGIC> <OPEN_PAREN> expressao() <CLOSE_PAREN>
    } catch (ParseException e) {
        handleError(e, "elemento");
    }
}

void indice(): {} {
        [ < OPEN_BRACE > expressao() < CLOSE_BRACE > ]
}

/////////////////////////////


void Declaration_Enumerado_E_ConstAndVars(): {} {
    try {
        <DECLARATION> (EnumeradoEouVars() | ConstAndVarsOnly())
    } catch (ParseException e) {
        handleError(e, "Declaration_Enumerado_E_ConstAndVars");
    }
}

void EnumeradoEouVars(): {} {
    try {
        <TYPE> <OPEN_BRACKET> ListaDeIdentificadores() <CLOSE_BRACKET> <DOT> (<DECLARATION> ConstAndVarsOnly())?
    } catch (ParseException e) {
        handleError(e, "EnumeradoEouVars");
    }
}

void ConstAndVarsOnly(): {} {
    try {
        <CONSTANT> <AND> <VARIABLE> <OPEN_BRACKET> ConstAndVarsOuVarsAndConstOuVarsOuConst() <CLOSE_BRACKET> <DOT>
    } catch (ParseException e) {
        handleError(e, "ConstAndVarsOnly");
    }
}

void ConstAndVarsOuVarsAndConstOuVarsOuConst(): {} {
    try {
        (<AS> (ConstAndVars() | VarsAndConst()) | Vars() | Const())
    } catch (ParseException e) {
        handleError(e, "ConstAndVarsOuVarsAndConstOuVarsOuConst");
    }
}

void Vars(): {} {
    try {
        <VARIABLE> ListaDeIdentificadores() <IS> TipoConstante() <EQUALS> Valor() <DOT> VarsAdicional()
    } catch (ParseException e) {
        handleError(e, "Vars");
    }
}

void VarsAdicional(): {} {
    try {
        (Vars())?
    } catch (ParseException e) {
        handleError(e, "VarsAdicional");
    }
}

void Const(): {} {
    try {
        <CONSTANT> ListaDeIdentificadores() <IS> TipoConstante() <DOT> ConstAdicional()
    } catch (ParseException e) {
        handleError(e, "Const");
    }
}

void ConstAdicional(): {} {
    try {
        (Const())?
    } catch (ParseException e) {
        handleError(e, "ConstAdicional");
    }
}

void ConstAndVars(): {} {
    try {
        Const() <AS> Vars() <DOT>
    } catch (ParseException e) {
        handleError(e, "ConstAndVars");
    }
}

void VarsAndConst(): {} {
    try {
        Vars() <AS> Const() <DOT>
    } catch (ParseException e) {
        handleError(e, "VarsAndConst");
    }
}

void TipoConstante(): {} {
    try {
        <INTEGER_DEF> | <REAL_DEF> | <LITERAL_DEF> | <LOGIC_DEF>
    } catch (ParseException e) {
        handleError(e, "TipoConstante");
    }
}

void TipoVariavel(): {} {
    try {
        <INTEGER_DEF> | <REAL_DEF> | <LITERAL_DEF> | <LOGIC_DEF>
    } catch (ParseException e) {
        handleError(e, "TipoVariavel");
    }
}

void Valor(): {} {
    try {
        <INTEGER_DEF> | <REAL_DEF> | <LITERAL_DEF>
    } catch (ParseException e) {
        handleError(e, "Valor");
    }
}

void ListaDeIdentificadores(): {} {
    try {
        <IDENTIFICADOR> ListaDeIdentificadoresAdicional()
    } catch (ParseException e) {
        handleError(e, "ListaDeIdentificadores");
    }
}

void ListaDeIdentificadoresAdicional(): {} {
    try {
        (ListaDeIdentificadores())?
    } catch (ParseException e) {
        handleError(e, "ListaDeIdentificadoresAdicional");
    }
}
